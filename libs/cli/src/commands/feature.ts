import { PROJECT_ROOT } from '../constants';
import fs from 'fs-extra';
import { resolve } from 'path';
import { logger } from '../gui';
import dedent from 'dedent';
import * as prettier from 'prettier';
import _ from 'lodash-es';

const serverRoot = resolve(PROJECT_ROOT, 'apps/server/src');
const clientRoot = resolve(PROJECT_ROOT, 'apps/client/src');
const sharedRoot = resolve(PROJECT_ROOT, 'libs/shared/src');

const createFile = async (path: string, content: string) => {
  const exists = fs.existsSync(path);

  fs.outputFileSync(
    path,
    await prettier.format(content, {
      htmlWhitespaceSensitivity: 'ignore',
      semi: true,
      tabWidth: 2,
      singleQuote: true,
      printWidth: 90,
      trailingComma: 'none',
      arrowParens: 'avoid',
      parser: 'babel-ts'
    })
  );

  logger.info(`${exists ? 'updated' : 'created'} file ${path}`);
};

const warningBanner = dedent`
  /**
   *  THE CONTENT OF THIS FILE IS AUTOGENERATED BY THE CLI. DONT EDIT IT DIRECTLY
   *  If you need to edit the template, to to libs/cli/src/commands/feature.ts
   */
`;

const createServerFeature = async (name: string) => {
  const capitalizedName = _.capitalize(name);

  const featureDir = resolve(serverRoot, 'features', name);
  fs.ensureDirSync(featureDir);

  const routerTemplate = dedent`
    import { contract } from '@drungeon-crawler/shared';
    import { initServer } from '@ts-rest/express';
    import { HTTP_STATUS_CODES } from '../../utils/errorFactory';
    import { pipe } from 'fp-ts/function';

    const s = initServer();

    export const ${name}Router = s.router(contract.${name}, {
      async getAll({ req: { container } }) {
        return pipe(
          await container.getAll${capitalizedName}sUseCase(),
          container.responseMapper(HTTP_STATUS_CODES.OK, container.${name}Mapper.toResponseArray)
        );
      },
    });
  `;

  const entityTemplate = dedent`
    import { UUID } from '@drungeon-crawler/shared';

    export type ${capitalizedName}Id = UUID;

    export type ${capitalizedName} = { id: ${capitalizedName}Id };
  `;

  const repositoryTemplate = dedent`
    import { PrismaClient } from '@prisma/client';
    import * as E from 'fp-ts/Either';
    import {
      UnexpectedError,
      errorFactory
    } from '../../utils/errorFactory';
    import { ${capitalizedName} } from './${name}.entity';
    import { handlePrismaError } from '../../utils/prisma';

    export type ${capitalizedName}Repository = {
      findAll(): Promise<E.Either<UnexpectedError, ${capitalizedName}[]>>;
      
    };

    export const ${name}Repository = ({ prisma }: { prisma: PrismaClient }): ${capitalizedName}Repository => {
      return {
        async findAll() {
          try {
            throw errorFactory.unexpected({ message: 'not implemented' })
          } catch (err) {
            return E.left(handlePrismaError()(err));
          }
        }
      };
    };
  `;

  const useCaseTemplate = dedent`
    import { UnexpectedError } from '../../../utils/errorFactory';
    import { ${capitalizedName} } from '../${name}.entity';
    import { ${capitalizedName}Repository } from '../${name}.repository';
    import { UseCase } from '../../../utils/helpers';

    export type GetAll${capitalizedName}Error = UnexpectedError;

    export type GetAll${capitalizedName}sUseCase = UseCase<void, ${capitalizedName}[], GetAll${capitalizedName}Error>;

    type Dependencies = { ${name}Repo: ${capitalizedName}Repository };

    export const getAll${capitalizedName}sUseCase =
      ({ ${name}Repo }: Dependencies): GetAll${capitalizedName}sUseCase =>
      async () => {
        return ${name}Repo.findAll();
      };
  `;

  const mapperTemplate = dedent`
    import { ${capitalizedName}Response } from '@drungeon-crawler/shared';
    import { ${capitalizedName} } from './${name}.entity';

    export type ${capitalizedName}Mapper = {
      toResponse(${name}: ${capitalizedName}): ${capitalizedName}Response;
      toResponseArray(${name}s: ${capitalizedName}[]): ${capitalizedName}Response[];
    };

    export const ${name}Mapper = (): ${capitalizedName}Mapper => {
      const map${capitalizedName} = (${name}: ${capitalizedName}): ${capitalizedName}Response => {
        return {
          id: ${name}.id,
        };
      };

      return {
        toResponse: map${capitalizedName},
        toResponseArray(${name}s) {
          return ${name}s.map(map${capitalizedName});
        }
      };
  };
  `;

  const providersTemplate = dedent`
    import { asFunction } from 'awilix';
    import { ${name}Mapper } from './${name}.mapper';
    import { ${name}Repository } from './${name}.repository';
    import { getAll${capitalizedName}sUseCase } from './usecases/getAll${capitalizedName}s.usecase';

    export const ${name}Providers = {
      ${name}Repo: asFunction(${name}Repository),
      ${name}Mapper: asFunction(${name}Mapper),

      getAll${capitalizedName}sUseCase: asFunction(getAll${capitalizedName}sUseCase),
    };
  `;

  await createFile(resolve(featureDir, `${name}.router.ts`), routerTemplate);
  await createFile(
    resolve(featureDir, `usecases/getAll${capitalizedName}s.usecase.ts`),
    useCaseTemplate
  );
  await createFile(resolve(featureDir, `${name}.repository.ts`), repositoryTemplate);
  await createFile(resolve(featureDir, `${name}.entity.ts`), entityTemplate);
  await createFile(resolve(featureDir, `${name}.mapper.ts`), mapperTemplate);
  await createFile(resolve(featureDir, `${name}.providers.ts`), providersTemplate);

  const features = fs
    .readdirSync(resolve(serverRoot, 'features'))
    .filter(fileOrdir =>
      fs.lstatSync(resolve(serverRoot, 'features', fileOrdir)).isDirectory()
    );
  const featuresWithRouter = features.filter(feature =>
    fs.existsSync(resolve(serverRoot, 'features', feature, `${feature}.router.ts`))
  );
  const featuresWithProviders = features.filter(feature =>
    fs.existsSync(resolve(serverRoot, 'features', feature, `${feature}.providers.ts`))
  );

  const routerIndexTemplate = dedent`
    ${warningBanner}
    import { contract } from '@drungeon-crawler/shared';
    import { initServer } from '@ts-rest/express';
    ${featuresWithRouter
      .map(
        feature => `import { ${feature}Router } from '../${feature}/${feature}.router';`
      )
      .join('\n')}
    
    const s = initServer();

    export const router = s.router(contract, {
      ${featuresWithRouter.map(feature => `${feature}: ${feature}Router`).join(',\n')}
    });
  `;

  await createFile(resolve(serverRoot, 'features/core/router.ts'), routerIndexTemplate);

  const containerTemplate = dedent`
    ${warningBanner}
    import { Express } from 'express';
    import { asFunction, asValue, Resolver } from 'awilix';
    import { Nullable, TypedAwilixContainer, createTypedContainer } from '@drungeon-crawler/shared';
    import { config } from './config';
    import { User } from './features/user/user.entity';
    ${featuresWithProviders
      .map(
        feature =>
          `import { ${feature}Providers } from './features/${feature}/${feature}.providers';`
      )
      .join('\n')}

    const dependencies = {
      config: asFunction(config),
      req: asValue(null),
      res: asValue(null),
      session: asValue(null),
        ${featuresWithProviders.map(feature => `...${feature}Providers`).join(',\n\t')}
    };

    export const container = createTypedContainer(dependencies);

    type Dependencies = typeof dependencies;
    type RequestScopedDependencies = Omit<Dependencies, 'req' | 'res' | 'session'> & {
      session: Resolver<Nullable<User>>;
      req: Resolver<Express['request']>;
      res: Resolver<Express['response']>;
    };

    export type Container = typeof container;
    export type RequestScopedContainer = TypedAwilixContainer<RequestScopedDependencies>;
    `;

  await createFile(resolve(serverRoot, 'container.ts'), containerTemplate);
};

const createClientFeature = async (name: string) => {
  const capitalizedName = _.capitalize(name);

  const featureDir = resolve(clientRoot, 'features', name);

  const apiTemplate = dedent`
  import { type ${capitalizedName}Response } from '@drungeon-crawler/shared';
  import { apiHandler } from '@/utils/api-helpers';
  import type { ApiClient } from '@/features/core/apiClient';

  export type ${capitalizedName}Api = {
    getAll: () => Promise<${capitalizedName}Response[]>;
  };

  type Dependencies = {
    apiClient: ApiClient;
  };
  export const ${name}Api = ({ apiClient }: Dependencies): ${capitalizedName}Api => {
    return {
      getAll: () => apiHandler(apiClient.${name}.getAll),
    };
  };
 `;

  const keysTemplate = dedent`
  import { createQueryKeys, type inferQueryKeys } from '@lukemorales/query-key-factory';

  export const ${name}Keys = createQueryKeys('${name}', {
    list: null
  });

  export type ${capitalizedName}KeysDefs = typeof ${name}Keys;
  export type ${capitalizedName}Keys = inferQueryKeys<typeof ${name}Keys>;
 `;

  const queriesTemplate = dedent`
    import type {
      UseApiMutationOptions,
      UseApiQueryOptions
    } from '@/features/core/composables/useApiQuery';
    import { queryKeys, type QueryKeys } from '@/features/core/queryKeys';
    import type { Contract } from '@drungeon-crawler/shared';
  

    export const use${capitalizedName}s = (
      options: UseApiQueryOptions<
        Contract['${name}']['getAll'],
        QueryKeys['${name}']['list']['queryKey']
      > = {}
    ) => {
      const { ${name}Api } = useContainer();

      return createUseApiQuery<Contract['${name}']['getAll']>()({
        ...options,
        ...queryKeys.${name}.list,
        queryFn: ${name}Api.getAll
      });
    };
 `;

  const providersTemplate = dedent`
    import { asFunction } from 'awilix';
    import { ${name}Api } from './api/${name}.api';

    export const ${name}Providers = {
      ${name}Api: asFunction(${name}Api)
    };
 `;

  await createFile(resolve(featureDir, `api/${name}.api.ts`), apiTemplate);
  await createFile(resolve(featureDir, `utils/${name}.keys.ts`), keysTemplate);
  await createFile(resolve(featureDir, `composables/queries.ts`), queriesTemplate);
  await createFile(resolve(featureDir, `${name}.providers.ts`), providersTemplate);

  const features = fs
    .readdirSync(resolve(clientRoot, 'features'))
    .filter(fileOrdir =>
      fs.lstatSync(resolve(clientRoot, 'features', fileOrdir)).isDirectory()
    );
  const featuresWithProviders = features.filter(feature =>
    fs.existsSync(resolve(clientRoot, 'features', feature, `${feature}.providers.ts`))
  );
  const featuresWithQueryKeys = features.filter(feature =>
    fs.existsSync(resolve(clientRoot, 'features', feature, `utils/${feature}.keys.ts`))
  );

  const containerTemplate = dedent`
     ${warningBanner}
     import { createTypedContainer } from '@drungeon-crawler/shared';
     ${featuresWithProviders
       .map(
         feature =>
           `import { ${feature}Providers } from './features/${feature}/${feature}.providers';`
       )
       .join('\n')}
    
     const dependencies = {
       ${featuresWithProviders.map(feature => `...${feature}Providers`).join(',\n')}
       
     };

     export const container = createTypedContainer(dependencies);
     export type Container = typeof container;
   `;

  const queryKeysIndexTemplate = dedent`
    ${warningBanner}
    import { mergeQueryKeys, type inferQueryKeyStore } from '@lukemorales/query-key-factory';
    ${featuresWithQueryKeys
      .map(
        feature => `import { ${feature}Keys } from '../${feature}/utils/${feature}.keys';`
      )
      .join('\n')}

      export const queryKeys = mergeQueryKeys(${featuresWithQueryKeys
        .map(feature => `${feature}Keys`)
        .join(', ')}
      );
      export type QueryKeys = inferQueryKeyStore<typeof queryKeys>;
  `;

  await createFile(resolve(clientRoot, `container.ts`), containerTemplate);
  await createFile(
    resolve(clientRoot, 'features/core/queryKeys.ts'),
    queryKeysIndexTemplate
  );
};

const createSharedFeature = async (name: string) => {
  const capitalizedName = _.capitalize(name);

  const featureDir = resolve(sharedRoot, 'features', name);
  fs.ensureDirSync(featureDir);

  const schemasTemplate = dedent`
    import { z } from 'zod';

    export const ${capitalizedName}Response = z.object({
      id: z.string(),
    });
    export type ${capitalizedName}Response = z.infer<typeof ${capitalizedName}Response>;
  `;

  const contractTemplate = dedent`
    import { initContract } from '@ts-rest/core';
    import { ErrorResponse } from '../core';
    import { ${capitalizedName}Response } from './${name}.schemas';
    import { z } from 'zod';

    const c = initContract();

    export const ${name}Contract = c.router(
      {
        getAll: {
          method: 'GET',
          path: '/',
          responses: {
            200: ${capitalizedName}Response.array(),
            500: ErrorResponse
          }
        },
      },
      {
        strictStatusCodes: true,
        pathPrefix: '/${name}s'
      }
    );

    export type ${capitalizedName}Contract = typeof ${name}Contract;
 `;

  const indexTemplate = dedent`
    export * from './${name}.schemas';
    export * from './${name}.contract';
 `;

  await createFile(resolve(featureDir, `${name}.contract.ts`), contractTemplate);
  await createFile(resolve(featureDir, `${name}.schemas.ts`), schemasTemplate);
  await createFile(resolve(featureDir, `index.ts`), indexTemplate);

  const features = fs
    .readdirSync(resolve(sharedRoot, 'features'))
    .filter(fileOrdir =>
      fs.lstatSync(resolve(sharedRoot, 'features', fileOrdir)).isDirectory()
    );
  const featuresWithContract = features.filter(feature =>
    fs.existsSync(resolve(sharedRoot, 'features', feature, `${feature}.contract.ts`))
  );

  const contractIndexTemplate = dedent`
    ${warningBanner}
    import { initContract } from '@ts-rest/core';
    ${featuresWithContract
      .map(feature => `import { ${feature}Contract } from './features/${feature}';`)
      .join('\n')}

    const c = initContract();

    export const contract = c.router(
      {
        ${featuresWithContract
          .map(feature => `${feature}: ${feature}Contract`)
          .join(',\n')}
      },
      {
        strictStatusCodes: true,
        pathPrefix: '/api'
      }
    );

    export type Contract = typeof contract;
  `;

  const featuresIndexTemplate = features
    .map(feature => `export * from './${feature}';`)
    .join('\n');

  await createFile(resolve(sharedRoot, `contract.ts`), contractIndexTemplate);
  await createFile(resolve(sharedRoot, 'features/index.ts'), featuresIndexTemplate);
};

export const feature = async (name: string) => {
  logger.warn(
    'refactor in progress because of changes in the progress structure. Sorry !'
  );
  return;

  const featureExists = [
    resolve(serverRoot, 'features', name),
    resolve(clientRoot, 'features', name),
    resolve(sharedRoot, 'features', name)
  ].some(fs.existsSync);

  if (featureExists) {
    logger.error(`Feature ${name} already exists.`);
    return;
  }
  feature;
  try {
    await createServerFeature(name);
    await createClientFeature(name);
    await createSharedFeature(name);
  } catch (err) {
    console.log(err);
  }
};
